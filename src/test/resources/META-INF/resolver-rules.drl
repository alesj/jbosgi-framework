/*
 * JBoss, Home of Professional Open Source
 * Copyright 2005, JBoss Inc., and individual contributors as indicated
 * by the @authors tag. See the copyright.txt in the distribution for a
 * full listing of individual contributors.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 */
package org.jboss.osgi.framework.resolver

import org.jboss.osgi.framework.resolver.internal.drools.WireCandidate
import org.jboss.osgi.framework.metadata.VersionRange
import org.osgi.framework.Bundle
import org.osgi.framework.Version

global org.jboss.logging.Logger log;

# Functions #######################################################################################

/**
* Returns TRUE is the version is in the given version range
*/
function boolean inRange(VersionRange range, Version version) 
{
   return range.isInRange(version);
}

# Types ###########################################################################################


# Rules ###########################################################################################

/**************************************************************************************************
* A rule that inserts the ImportPackage facts for newly inserted 
* ResolverBundle objects.
*/
rule "Add ImportPackage for new ResolverBundle"
salience 2000
when
	$importer : ResolverBundle( state == Bundle.INSTALLED, resolved == false )
	$import : ImportPackage( ) from $importer.importPackages
	not ImportPackage( owner == $importer, this == $import ) 
then
    log.debug("Add " + $import);
    insert( $import );
end

/**************************************************************************************************
* A rule that inserts the ExportPackage facts for newly inserted 
* ResolverBundle objects.
*/
rule "Add ExportPackage for new ResolverBundle"
salience 2000
when
	$exporter : ResolverBundle( (state == Bundle.INSTALLED || bundleId == 0), resolved == false )
	$export : ExportPackage( ) from $exporter.exportPackages
	not ExportPackage( owner == $exporter, this == $export ) 
then
    log.debug("Add " + $export);
    insert( $export );
end

/**************************************************************************************************
* A rule that inserts the RequiredBundle facts for newly inserted 
* ResolverBundle objects.
*/
rule "Add RequiredBundle for new ResolverBundle"
salience 2000
when
	$importer : ResolverBundle( state == Bundle.INSTALLED, resolved == false )
	$reqbnd : RequiredBundle( ) from $importer.requiredBundles
	not RequiredBundle( owner == $importer, this == $reqbnd ) 
then
    log.debug("Add " + $reqbnd);
    insert( $reqbnd );
end


/**************************************************************************************************
* A rule that inserts the WireCandidate facts for every combination 
* of matching import/export package names.
*/
rule "Add WireCandidate"
salience 1000
when
    $export : ExportPackage( )
    $import : ImportPackage( name == $export.name, exporter == null )
then
    WireCandidate wc = new WireCandidate();
    wc.setImportPackage( $import );
    wc.setExportPackage( $export );
    log.debug("Add " + wc);
    insert ( wc );
end

/**************************************************************************************************
* A rule that retracts the WireCandidate if there is a package
* version miss-match.
*/
rule "Retract package version miss-match"
salience 1000
when
    $import : ImportPackage( exporter == null, version != VersionRange.allVersions )
    $wc : WireCandidate( importPackage == $import )
    not( eval( inRange( $import.getVersion(), $wc.getExportPackage().getVersion())))
then
    log.debug("Package version missmatch - Retract " + $wc);
    retract ( $wc );
end

/**************************************************************************************************
* A rule that retracts the WireCandidate if there is a miss-match
* of the bundle-symbolic-name on the ImportPackage.
*/
rule "Retract bundle symbolic name miss-match"
salience 1000
when
    $import : ImportPackage( exporter == null, bundleSymbolicName != null )
    $wc : WireCandidate( importPackage == $import, exportPackage.owner.symbolicName != $import.bundleSymbolicName )
then
    log.debug("Bundle-SymbolicName missmatch - Retract " + $wc);
    retract ( $wc );
end

/**************************************************************************************************
* A rule that retracts the WireCandidate if there is a miss-match
* of the bundle-version on the ImportPackage.
*/
rule "Retract bundle version miss-match"
salience 1000
when
    $import : ImportPackage( exporter == null, bundleVersion != null )
    $wc : WireCandidate( importPackage == $import )
    not( eval( inRange( $import.getBundleVersion(), $wc.getExportPackage().getOwner().getVersion())))
then
    log.debug("Bundle-Version missmatch - Retract " + $wc);
    retract ( $wc );
end

/**************************************************************************************************
* A rule that retracts the WireCandidate if there is a miss-match
* of package attributes.
*/
rule "Retract package attributre miss-match"
salience 1000
when
    $export : ExportPackage( )
    $import : ImportPackage( exporter == null )
    $wc : WireCandidate( importPackage == $import, exportPackage == $export )
    not( eval( $export.matchAttributes( $import ) ) )
then
    log.debug("Attribute missmatch - Retract " + $wc);
    retract ( $wc );
end

/**************************************************************************************************
* A rule that retracts a WireCandidate if there is another 
* associated with a higher version on the ExportPackage.
*/
rule "Retract WireCandidate to lower version"
salience 400
when
    $bndkeep : ResolverBundle(  )
    $expkeep : ExportPackage( owner  == $bndkeep )
    $wckeep : WireCandidate( exportPackage == $expkeep )
    $bnddel : ResolverBundle( )
    $expdel : ExportPackage( this != $expkeep, owner  == $bnddel )
    $wcdel : WireCandidate( importPackage == $wckeep.importPackage, exportPackage == $expdel )
    eval( $expkeep.getVersion().compareTo($expdel.getVersion()) > 0 ) 
    eval( $bnddel.isResolved() == false || ( $bnddel.isResolved() == true && $bndkeep.isResolved() == true ) )
then
    log.debug("Retract lower version " + $wcdel);
    retract ( $wcdel );
end

/**************************************************************************************************
* A rule that retracts a WireCandidate if there is another 
* associated with a lower bundle id.
*/
rule "Retract WireCandidate to higher bundle id"
salience 300
when
    $bndkeep : ResolverBundle(  )
    $expkeep : ExportPackage( owner  == $bndkeep )
    $wckeep : WireCandidate( exportPackage == $expkeep )
    $bnddel : ResolverBundle( )
    $expdel : ExportPackage( this != $expkeep, owner  == $bnddel )
    $wcdel : WireCandidate( importPackage == $wckeep.importPackage, exportPackage == $expdel )
    eval ( $bnddel.getBundleId() > $bndkeep.getBundleId() ) 
    eval( $bnddel.isResolved() == false || ( $bnddel.isResolved() == true && $bndkeep.isResolved() == true ) )
then
    log.debug("Retract higher bundle id " + $wcdel);
    retract ( $wcdel );
end

/**************************************************************************************************
* A rule that retracts a WireCandidate if there is another 
* associated with an already resolved exporter.
*/
rule "Retract WireCandidate to unresolved exporter"
salience 200
when
    $bndkeep : ResolverBundle( resolved == true )
    $expkeep : ExportPackage( owner  == $bndkeep )
    $wckeep : WireCandidate( exportPackage == $expkeep )
    $bnddel : ResolverBundle( resolved == false )
    $expdel : ExportPackage( this != $expkeep, owner  == $bnddel )
    $wcdel : WireCandidate( importPackage == $wckeep.importPackage, exportPackage == $expdel )
then
    log.debug("Retract unresolved exporter " + $wcdel);
    retract ( $wcdel );
end

/**************************************************************************************************
* A rule that sets the provider for a RequiredBundle if there is a match
*/
rule "RequiredBundle match on bundle-symbolic-name only"
salience 100
when
    $provider : ResolverBundle( )
    $reqbnd : RequiredBundle( symbolicName == $provider.symbolicName, version == null, provider == null )
then
    log.debug("RequiredBundle match " + $reqbnd + " --> " + $provider);
    modify ( $reqbnd ) { setProvider( $provider ) };
end

/**************************************************************************************************
* A rule that sets the provider for a RequiredBundle if there is a match on 
* bundle-symbolic-name and bundle-version
*/
rule "RequiredBundle match on bundle-symbolic-name and bundle-version"
salience 100
when
    $provider : ResolverBundle( )
    $reqbnd : RequiredBundle( symbolicName == $provider.symbolicName, version != null, provider == null )
    eval( inRange( $reqbnd.getVersion(), $provider.getVersion()))
then
    log.debug("RequiredBundle match " + $reqbnd + " --> " + $provider);
    modify ( $reqbnd ) { setProvider( $provider ) };
end

/**************************************************************************************************
* A rule that applies the WireCandidate if there is only one 
* possible WireCandidate left associated with an ImportPackage.
* The exporter must be resolved.
*/
rule "Wire to resolved exporter"
salience 50
when
    $importer : ResolverBundle( resolved == false )
    $import : ImportPackage( owner == $importer, exporter == null )
    $exporter : ResolverBundle( resolved == true )
    $export : ExportPackage( owner == $exporter )
    $wc : WireCandidate( importPackage == $import, exportPackage == $export )
    not( WireCandidate( this != $wc, importPackage == $import ) )
then
    log.debug("Wire to resolved exporter " + $wc);
    modify ( $import ) { setExporter( $wc.getExportPackage() ) };
    retract ( $wc );
end

/**************************************************************************************************
* A rule that applies the WireCandidate if there is only one 
* possible WireCandidate left associated with an ImportPackage.
* The exporter is also the importer.
*/
rule "Wire self import"
salience 50
when
    $import : ImportPackage( exporter == null )
    $export : ExportPackage( owner == $import.owner )
    $wc : WireCandidate( importPackage == $import, exportPackage == $export )
    not( WireCandidate( this != $wc, importPackage == $import ) )
then
    log.debug("Wire self import " + $wc);
    modify ( $import ) { setExporter( $wc.getExportPackage() ) };
    retract ( $wc );
end

/**************************************************************************************************
* A rule that marks the ResolverBundle as resolved on the condition that
*
* 	# There are no ImportPackages
* 	# All non-optional RequiredBundles have a provider
*/
rule "Resolve required imports"
salience 20
when
    $importer : ResolverBundle( state != Bundle.UNINSTALLED, resolved == false )
    not( ImportPackage( owner == $importer ))
    not( RequiredBundle( owner == $importer, optional == false, provider == null ))
then
    log.debug("Resolved " + $importer);
    modify ( $importer ) { markResolved ( ) };
end

/**************************************************************************************************
* A rule that marks the ResolverBundle as resolved on the condition that
*
* 	# All non-optional ImportPackage wire to an exporter
* 	# All non-optional RequiredBundles have a provider
*/
rule "Resolve optional imports"
when
    $importer : ResolverBundle( state != Bundle.UNINSTALLED, resolved == false )
    not( ImportPackage( owner == $importer, optional == false, exporter == null ))
    not( RequiredBundle( owner == $importer, optional == false, provider == null ))
then
    log.debug("Resolved " + $importer);
    modify ( $importer ) { markResolved ( ) };
end

/**************************************************************************************************
* A rule that retracts ImportPackage facts for UNINSTALLED bundles
*/
rule "Retract uninstalled ImportPackage"
when
    $importer : ResolverBundle( state == Bundle.UNINSTALLED )
    $import : ImportPackage( owner == $importer )
then
    log.debug("Uninstall " + $import);
    retract ( $import );
end

/**************************************************************************************************
* A rule that retracts ExportPackage facts for UNINSTALLED bundles
*/
rule "Retract uninstalled ExportPackage"
when
    $exporter : ResolverBundle( state == Bundle.UNINSTALLED )
    $export : ExportPackage( owner == $exporter )
then
    log.debug("Uninstall " + $export);
    retract ( $export );
end

/**************************************************************************************************
* A rule that retracts WireCandidate facts for UNINSTALLED ImportPackages
*/
rule "Retract uninstalled WireCandidate/ImportPackage"
when
    $wc : WireCandidate( )
    not ( ImportPackage ( this == $wc.importPackage) ) 
then
    log.debug("Uninstall " + $wc);
    retract ( $wc );
end

/**************************************************************************************************
* A rule that retracts WireCandidate facts for UNINSTALLED ExportPackages
*/
rule "Retract uninstalled WireCandidate/ExportPackage"
when
    $wc : WireCandidate( )
    not ( ExportPackage ( this == $wc.exportPackage) ) 
then
    log.debug("Unistall " + $wc);
    retract ( $wc );
end

/**************************************************************************************************
* A rule that retracts RequiredBundles facts for UNINSTALLED ResolverBundles
*/
rule "Retract uninstalled RequiredBundles"
when
    $importer : ResolverBundle( state == Bundle.UNINSTALLED )
    $reqbnd : RequiredBundle( owner == $importer )
then
    log.debug("Uninstall " + $reqbnd);
    retract ( $reqbnd );
end

/**************************************************************************************************
* A rule that reports unresolved ImportPackage objects 
*/
rule "Report unresolved import"
salience -1000
when
    $import : ImportPackage( exporter == null, optional == false )
then
    log.debug("Unresolved " + $import );
end

